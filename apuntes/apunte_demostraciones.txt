
## Ejemplo 1
----------------------------------------------------------------------

curry :: ((a, b)-> c) -> (a->b->c)
{C} curry f = (\x y -> f(x,y))

uncurry :: (a->b->c) -> ((a, b)->c)
{U} uncurry f = (\(x, y) -> f x y)

(.) :: (b->c) -> (a->b) ->(a->c)

{COMP} (f . g) x = f (g x)

id :: a -> a 
{I} id x = x


-- Por principio de extensionalidad vemos que ∀x::a->b->C.

-- Probar (curry . uncurry) x = id x

(curry . uncurry) x 
 {COMP} = curry (uncurry x)
    {U} = curry (\(z,y)-> x z y)
    {C} = \j i -> (\(z,y)->x z y)(j,i) 
    {β} = \j i -> x j i
haskell = (j -> (\i -> x j i)) 
    {η} =  \j -> x j 
    {η} = x
        = id x 
        = x


## Ejemplo 2 
----------------------------------------------------------------------

prod :: Either Int (Int, Int) -> Either Int (Int, Int) -> Either Int (Int, Int)
{P0} prod (Left x) (Left y) = Left (x * y)
{P1} prod (Left x) (Right (y, z)) = Right (x * y, x * z)
{P2} prod (Right (y, z)) (Left x) = Right (y * x, z * x)
{P3} prod (Right (w, x)) (Right (y, z)) = Left (w * y + x * z)

-- Probar ∀p::Either Int (Int, Int) . ∀q::Either Int (Int, Int) . prod p q = prod q p

p:: Either Int (Int,Int) por el lema de generacion de la suma: hay 2 casos:
    ▹ caso(A):  ∃k :: Int talque p = Left k
    ▹ caso(B):  ∃l :: (Int,Int) talque p = Right l

            Por lema de generacion de pares: 
             ∃x :: Int, y :: Int tales que l = (x,y)

    ▹ caso(C): ∃k′:: Int . q = Left k′
    ▹ caso(D): ∃x,y′:: Int . q = Right (x′, y′) 


-- CASO (A) y (C) --

   prod p q = prod (Left k)(Left k′) 
{PO} = Left (k*k′)
{..} = Left (k′*k)
{PO} = prod (Left k′)(Left k)
     = prod q p 

-- CASO (B) y (C) --

    prod p q = (Right (x, y))(Left k′)
{P2} = Right (x*k′, y*k′)
{..} = (k′* x, k′ * y) 
{P1} = prod(Left k′)(Right (x,y))
     = prod q p


## Ejemplo 3
----------------------------------------------------------------------

vacio :: Conj a
{V} vacio = \ -> False

interseccion :: Conj a-> Conj a-> Conj a
{I} interseccion c d = \e -> c e && d e

agregar :: Eq a => a -> Conj a -> Conj a
{A} agregar e c = \e -> e == x || c e

diferencia :: Conj a -> Conj a-> Conj a
{D} diferencia c d = \e -> c e && not (d e)


-- Probar ∀c::Conj a . ∀d::Conj a . interseccion d (diferencia c d) = vacio

-- Por extensionalidad basta ver que ∀x::a . interseccion d (diferencia c d) x = vacio x

vacio x 
 {v} = (\_ -> False) x 
 {β} = False

interseccion d (diferencia c d) x 
 {D} = interseccion(\e′-> c e && not (d e)) x 
 {I} = (\e′-> d e′ && (\e->c e && not(d e))e′) x
 {β} = (\e′-> d e′ && (c e′ && not(d e′))) x
 {β} = d x && (c x && not(d x))
     = False && c x 
     = False


## Ejemplo 3 :: INDUCCION SOBRE LISTAS
----------------------------------------------------------------------

length1 :: [a] -> Int
{L10} length1 [] = 0
{L11} length1 ( :xs) = 1 + length1 xs

length2 :: [a] -> Int
{L2} length2 = foldr (\ res -> 1 + res) 0

Recordemos:
foldr :: (a -> b -> b) -> b -> [a] -> b
{F0} foldr f z [] = z
{F1} foldr f z (x:xs) = f x (foldr f z xs)

-- Probar que length1 = length2 

-- Por propiedad de extensionalidad quiero ver que ∀xs::[a] . length1 xs = length2 xs

P(xs):  length1 xs = length2 xs

Para ver que vale ∀xs::[a]. P(xs) por induccion estructural, veo que vale: 
    ⚈ P([]) -- caso base
    ⚈ ∀x::a . P(xs) ⇒ P(x:xs) -- caso inductivo

-- Caso Base --

   P([]) = length1 [] = length2 []
   
   length1 []
   {L10} = 0 

   length2 [] 
   {L2} = foldr(\_ res -> 1 + res) 0 []
   {F0} = 0

-- Paso Inductivo -- 

   ∀x::a . P(xs) ⇒ P(x:xs)

-- Recuerdo: {H1} ≣ P(xs) ≡ (length1 xs = length2 xs)

   ⚈ P(xs)   ≡ (length1 xs = length2 xs) qvq P(x:xs)
   ⚈ P(x:xs) ≡ length1 (x:xs) = length2 (x:xs)

   length1(x:xs) 
   {L11} ≡  1 + length1 xs

   length2(x:xs) 
   {L2} = foldr(\_ res -> 1 + res) 0 (x:xs)    
   {F1} = (\_ res -> 1 + res) x (foldr (\_ res -> 1 + res) 0 xs) 
   {L2} = (\_ res -> 1 + res) x (length2 xs) 
    {β} = (\_ res -> 1 + res)(length2 xs)
    {β} = (\_-> \res -> 1 + res)(length2 xs)
    {β} = \res -> 1 + res (length2 xs)
    {β} = 1 + length2 xs 
   {HI} = 1 + length1 xs


## Ejemplo 4 :: DEMOSTRAR IMPLICACIONES
----------------------------------------------------------------------

Ord a ⇒ ∀e::a . ∀ys::[a] . (elem e ys ) e ⇒ maximum ys)

elem :: Eq a => a -> [a] -> Bool
{E0} elem e [] = False
{E1} elem e (x:xs) = (e == x) || elem e xs

maximum :: Ord a => [a] -> a
{M0} maximum [x] = x
{M1} maximum (x:y:ys) = if x < maximum (y:ys) then maximum (y:ys) else x

Sabemos que valen Eq a y Ord a. Queremos ver que, para toda lista ys, vale:

P(ys) = ∀e::a . (elem e ys ⇒ e ≤ maximum ys)

-- Por induccion estructural en ys, vemos que:
   ⚈ P([])
   ⚈ ∀x::a . P(xs)⇒ P(x:xs) 

-- Caso Base --

P([]) = ∀e::a . (elem e []) ⇒ e ≤ maximum [])
Recuerdo: {HI} = P(ys)

P(ys) = ∀e::a . elem e ys ⇒ e ≤ maximum ys queremos ver que vale P(y:ys) 

{HI} = P(ys) = ∀e::a . elem e ys ⇒ e ≤ maximum ys
P(y:ys) = ∀e::a . elem e (y:ys) ⇒ e ≤ maximum (y:ys)

Sea e::a talque True = elem e (y:ys) qvq e ≤ maximum (y:ys)
-- Por el lema de generacion de listas:
    (A) ys = []
    (B) ∃ z::a, za::[a] tales que ys = (z:zs)

-- caso(A) --

    qvq:  
    e ≤ maximum (y:ys) 
         ≡ e ≤ maximum [y] 
    {MO} ≡ e ≤ y

  -- ya se que True = elem e (y:ys), entonces en este caso ( True = elem e (y:[]) )

    True = elem e (y: []) 
         = (e == y) || elem e [] 
    {E0} = (e == y) || False 
         = (e == y) 

  -- entonces e = y ⇒ e ≤ y

-- caso(B) --

    qvq e ≤ maximum (y:ys) 
     ≡ e ≤ maximum (y:z:zs) 
     ≡ e ≤ if y < maximum (z:zs) then maximum (z:zs) else y 
     ≡ e ≤ if y < (maximum ys) then maximum (maximum ys) else y = (☆)

    por el lema de gen de Bool
        (B1) y < maximum ys = True
        (B2) y < maximum ys = False

    -- caso(B1)

    (☆) ≡ e ≤ if True then maximum ys else y
        ≡ e ≤ maximum ys
   {HI} ≡ P(ys) = ∀e::a . elem ys ⇒ e ≤ maximum ys 

True = elem e (y:ys) = (e == y) || elem e ys 

    por el lema de gen de Bool
        (B11) (e == ys) = True
        (B12) (e == y)  = False

    -- caso(B11)  
         (e=y) entonces lo que quiero ver es  que (☆) y ≤ maximo ys
         Por (H1) (B1) Vale (y < maximum ys) y por lo tanto (y ≤ maximum ys)
    
    -- caso(B12) 
         (e==y) = False entonces
          True  = (e==y) || elem e ys 
                = False || elem e ys 
                = elem e ys

    {H1} = P(ys) = ∀e::a . elem e ys ⇒ e ≤ maximum ys
    por HI, vale e ≤ maximum ys (☆)

    -- Caso(B2)
        y < maximum ys = False ⇒ y ≤ maximum ys
        (☆) e ≤ if False then (maximum ys) else y
              ≡ e ≤ y

        Lema de gen de Bool:
           ● (e==y) = True ->  e=y -> e ≤ y
           ● (e==y) = False -> elem e ys = True ⇒ e ≤ maximum ys ... e ≤ maximum ys ∴ e ≤ y 

        True = elem e (y:ys)  
        {HI} = (e==y) || elem e ys 
